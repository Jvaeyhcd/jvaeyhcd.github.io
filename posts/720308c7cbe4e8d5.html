


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGContextRef绘图－iOS球形波浪加载进度控件－HcdProcessView详解 [ Jvaeyhcd&#39;s Note ]</title>
  <link rel="shortcut icon" href="/img/favicon.ico">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  
    <!-- stylesheets list from _config.yml -->
    
      <link rel="stylesheet" href="/css/dexo.css">
    
      <link rel="stylesheet" href="/css/custom.css">
    
      <link rel="stylesheet" href="/css/post.css">
    
      <link rel="stylesheet" href="/css/page.css">
    
      <link rel="stylesheet" href="/css/layout.css">
    
      <link rel="stylesheet" href="/css/font-awesome.min.css">
    
  
<meta name="generator" content="Hexo 5.4.2"></head>
<body>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="layout-container">
  <div class="layout-header">
    

<div class="main-nav">
  
  <div class="container">
    <header class="group top-nav">
      <nav class="navbar logo-w navbar-left">
        <a href="/" class="logo">Jvaeyhcd's Note</a>
      </nav>
      <div class="navigation-toggle" onClick="hideShowMenu()">
        <span class="logo">Jvaeyhcd's Note</span>
      </div>
      <nav id="navbar-menu" class="navbar item-nav navbar-right">
        <ul>
          
            <li><a href="/">Home</a></li>
          
            <li><a href="/archives">Archives</a></li>
          
            <li><a href="/tag">Tags</a></li>
          
            <li><a target="_blank" rel="noopener" href="https://github.com/Jvaeyhcd">Github</a></li>
          
        </ul>
      </nav>
    </header>
  </div>
</div>
  </div>
  <div class="layout-content">
    <div id="content-outer" class="container container-box">
      <div id="content-inner" class="content-view">
        <div class="post-content-box">
  <article id="post" class="post-detail-box box-section shadow">
    <div class="post-title">
      CGContextRef绘图－iOS球形波浪加载进度控件－HcdProcessView详解
    </div>
    <div class="post-base-box">
      <time datetime="2016-09-20T05:18:12.000Z">
        Posted on 2016-09-20
      </time>
      
        <div class="category-item">
          In
          <a class="category-link-grey-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/">技术杂谈</a>
        </div>
      
      <span id="busuanzi_container_page_pv">
        &nbsp;visitors <span id="busuanzi_value_page_pv"></span>
      </span>
    </div>
    <div class="post-body">
      <p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/239a650bf73a">《iOS球形波浪加载进度控件－HcdProcessView》</a>这篇文章已经展示了我在项目中编写的一个球形进度加载控件HcdProcessView，这篇文章我要简单介绍一下我的制作过程。</p>
<img src="/posts/720308c7cbe4e8d5/905614-aad2c9e81a2873c7.gif" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-aad2c9e81a2873c7.gif) -->

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我放弃了使用通过改变图片的位置来实现上面的动画效果，虽然这样也可以实现如上的效果，但是从性能和资源消耗上来说都不是最好的选择。这里我采用了通过上下文（也就是CGContextRef）来绘制这样的效果，大家对它应该并不陌生，它既可以绘制直线、曲线、多边形圆形以及各种各样的几何图形。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>我们可以将上面的复杂图形拆分成如下几步：</p>
<ol>
<li>绘制最外面的一圈刻度尺</li>
<li>绘制表示进度的刻度尺</li>
<li>绘制中间的球形加载界面<span id="more"></span></li>
</ol>
<h3 id="绘制刻度尺"><a href="#绘制刻度尺" class="headerlink" title="绘制刻度尺"></a>绘制刻度尺</h3><p>如果你先要在控件中绘制自己想要的图形，你需要重写UIView的<code>drawRect</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    [<span class="keyword">self</span> drawScale:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>drawRect</code>方法中，我们先画出了刻度尺的图形，刻度尺是由一圈短线在一个圆内围成的一个圆。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  画比例尺</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param context 全局context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)drawScale:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, _scaleDivisionsWidth);<span class="comment">//线的宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先将参照点移到控件中心</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, fullRect.size.width / <span class="number">2</span>, fullRect.size.width / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线的颜色</span></span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.655</span> green:<span class="number">0.710</span> blue:<span class="number">0.859</span> alpha:<span class="number">1.00</span>].CGColor);<span class="comment">//线框颜色</span></span><br><span class="line">    <span class="comment">//绘制一些图形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _scaleCount; i++) &#123;</span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, scaleRect.size.width/<span class="number">2</span> - _scaleDivisionsLength, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, scaleRect.size.width/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//    CGContextScaleCTM(ctx, 0.5, 0.5);</span></span><br><span class="line">        <span class="comment">//渲染</span></span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRotateCTM</span>(context, <span class="number">2</span> * M_PI / _scaleCount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制刻度尺外的一个圈</span></span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.694</span> green:<span class="number">0.745</span> blue:<span class="number">0.867</span> alpha:<span class="number">1.00</span>].CGColor);<span class="comment">//线框颜色</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">CGContextAddArc</span> (context, <span class="number">0</span>, <span class="number">0</span>, scaleRect.size.width/<span class="number">2</span> - _scaleDivisionsLength - <span class="number">3</span>, <span class="number">0</span>, M_PI* <span class="number">2</span> , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复原参照点</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, -fullRect.size.width / <span class="number">2</span>, -fullRect.size.width / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要用到两个东西一个是<code>CGContextAddArc</code>，一个是<code>CGContextAddLineToPoint</code>。创建圆弧的方法有两种一种是<code>CGContextAddArc</code>，一种是<code>CGContextAddArcToPoint</code>，这里画的圆比较简单所以用的是<code>CGContextAddArc</code>,<code>CGContextAddArcToPoint</code>在后面也会用到（我会在用到的地方详解）。</p>
<h4 id="CGContextAddArc"><a href="#CGContextAddArc" class="headerlink" title="CGContextAddArc"></a>CGContextAddArc</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CGContextAddArc</span> (</span><br><span class="line">   <span class="built_in">CGContextRef</span> c,    </span><br><span class="line">   <span class="built_in">CGFloat</span> x,             <span class="comment">//圆心的x坐标</span></span><br><span class="line">   <span class="built_in">CGFloat</span> y,   <span class="comment">//圆心的x坐标</span></span><br><span class="line">   <span class="built_in">CGFloat</span> radius,   <span class="comment">//圆的半径</span></span><br><span class="line">   <span class="built_in">CGFloat</span> startAngle,    <span class="comment">//开始弧度</span></span><br><span class="line">   <span class="built_in">CGFloat</span> endAngle,   <span class="comment">//结束弧度</span></span><br><span class="line">   <span class="type">int</span> clockwise          <span class="comment">//0表示顺时针，1表示逆时针</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里需要创建一个完整的圆，那么 开始弧度就是0 结束弧度是 2PI， 因为圆周长是 2<em>PI</em>radius。函数执行完后，current point就被重置为(x,y)。<code>CGContextTranslateCTM(context, fullRect.size.width / 2, fullRect.size.width / 2);</code>已经将current point移动到了<code>(fullRect.size.width / 2, fullRect.size.width / 2)</code>。</p>
<h4 id="CGContextAddLineToPoint"><a href="#CGContextAddLineToPoint" class="headerlink" title="CGContextAddLineToPoint"></a>CGContextAddLineToPoint</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CGContextAddLineToPoint</span> (</span><br><span class="line">   <span class="built_in">CGContextRef</span> c,</span><br><span class="line">   <span class="built_in">CGFloat</span> x,</span><br><span class="line">   <span class="built_in">CGFloat</span> y</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> 创建一条直线，从current point到 (x,y)<br> 然后current point会变成(x,y)。<br>由于短线不连续，所以通过for循环来不断画短线，<code>_scaleCount</code>代表的是刻度尺的个数，每次循环先将current point移动到<code>(scaleRect.size.width/2 - _scaleDivisionsLength, 0)</code>点，<code>_scaleDivisionsLength</code>代表短线的长度。绘制完短线后将前面绘制完成的图形旋转一个刻度尺的角度<code>CGContextRotateCTM(context, 2 * M_PI / _scaleCount);</code>，将最终的绘制渲染后就得到了如下的刻度尺：</p>
<img src="/posts/720308c7cbe4e8d5/905614-282356612ba9f28c.png" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-282356612ba9f28c.png) -->

<h3 id="刻度尺上的进度绘制"><a href="#刻度尺上的进度绘制" class="headerlink" title="刻度尺上的进度绘制"></a>刻度尺上的进度绘制</h3><p>首先在<code>drawRect</code>中添加<code>drawProcessScale</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    [<span class="keyword">self</span> drawScale:context];</span><br><span class="line">    [<span class="keyword">self</span> drawProcessScale:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>drawProcessScale</code>方法中实现左右两部分的刻度尺进度绘制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  比例尺进度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param context 全局context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)drawProcessScale:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, _scaleDivisionsWidth);<span class="comment">//线的宽度</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, fullRect.size.width / <span class="number">2</span>, fullRect.size.width / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.969</span> green:<span class="number">0.937</span> blue:<span class="number">0.227</span> alpha:<span class="number">1.00</span>].CGColor);<span class="comment">//线框颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = (_scaleCount / <span class="number">2</span> + <span class="number">1</span>) * currentPercent;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleAngle = <span class="number">2</span> * M_PI / _scaleCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制左边刻度进度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">0</span>, scaleRect.size.width/<span class="number">2</span> - _scaleDivisionsLength);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">0</span>, scaleRect.size.width/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//    CGContextScaleCTM(ctx, 0.5, 0.5);</span></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRotateCTM</span>(context, scaleAngle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制右边刻度进度</span></span><br><span class="line">    <span class="built_in">CGContextRotateCTM</span>(context, -count * scaleAngle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">0</span>, scaleRect.size.width/<span class="number">2</span> - _scaleDivisionsLength);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="number">0</span>, scaleRect.size.width/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//    CGContextScaleCTM(ctx, 0.5, 0.5);</span></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRotateCTM</span>(context, -scaleAngle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, -fullRect.size.width / <span class="number">2</span>, -fullRect.size.width / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绘制完后效果如下：</p>
<img src="/posts/720308c7cbe4e8d5/905614-e85a60e792a0c99d.png" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-e85a60e792a0c99d.png) -->


<h3 id="水的波浪效果绘制"><a href="#水的波浪效果绘制" class="headerlink" title="水的波浪效果绘制"></a>水的波浪效果绘制</h3><p>终于到了最主要也是最难的效果绘制了，对于带有波浪不断滚动的效果是采用NSTimer来不断绘制每一帧图形实现的，现在简单介绍下每一帧的绘制方法。<br>首先在<code>drawRect</code>中添加<code>drawWave</code>方法，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    [<span class="keyword">self</span> drawScale:context];</span><br><span class="line">    [<span class="keyword">self</span> drawProcessScale:context];</span><br><span class="line">    [<span class="keyword">self</span> drawWave:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawWave</code>中实现如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  画波浪</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param context 全局context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)drawWave:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> frontPath = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> backPath = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//画水</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [_frontWaterColor <span class="built_in">CGColor</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> offset = _scaleMargin + _waveMargin + _scaleDivisionsWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> frontY = currentLinePointY;</span><br><span class="line">    <span class="type">float</span> backY = currentLinePointY;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> radius = waveRect.size.width / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> frontStartPoint = <span class="built_in">CGPointMake</span>(offset, currentLinePointY + offset);</span><br><span class="line">    <span class="built_in">CGPoint</span> frontEndPoint = <span class="built_in">CGPointMake</span>(offset, currentLinePointY + offset);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> backStartPoint = <span class="built_in">CGPointMake</span>(offset, currentLinePointY + offset);</span><br><span class="line">    <span class="built_in">CGPoint</span> backEndPoint = <span class="built_in">CGPointMake</span>(offset, currentLinePointY + offset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> x = <span class="number">0</span>; x &lt;= waveRect.size.width; x++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前浪绘制</span></span><br><span class="line">        frontY = a * sin( x / <span class="number">180</span> * M_PI + <span class="number">4</span> * b / M_PI ) * amplitude + currentLinePointY;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> frontCircleY = frontY;</span><br><span class="line">        <span class="keyword">if</span> (currentLinePointY &lt; radius) &#123;</span><br><span class="line">            frontCircleY = radius - sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (frontY &lt; frontCircleY) &#123;</span><br><span class="line">                frontY = frontCircleY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentLinePointY &gt; radius) &#123;</span><br><span class="line">            frontCircleY = radius + sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (frontY &gt; frontCircleY) &#123;</span><br><span class="line">                frontY = frontCircleY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fabs(<span class="number">0</span> - x) &lt; <span class="number">0.001</span>) &#123;</span><br><span class="line">            frontStartPoint = <span class="built_in">CGPointMake</span>(x + offset, frontY + offset);</span><br><span class="line">            <span class="built_in">CGPathMoveToPoint</span>(frontPath, <span class="literal">NULL</span>, frontStartPoint.x, frontStartPoint.y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        frontEndPoint = <span class="built_in">CGPointMake</span>(x + offset, frontY + offset);</span><br><span class="line">        <span class="built_in">CGPathAddLineToPoint</span>(frontPath, <span class="literal">nil</span>, frontEndPoint.x, frontEndPoint.y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后波浪绘制</span></span><br><span class="line">        backY = a * cos( x / <span class="number">180</span> * M_PI + <span class="number">3</span> * b / M_PI ) * amplitude + currentLinePointY;</span><br><span class="line">        <span class="built_in">CGFloat</span> backCircleY = backY;</span><br><span class="line">        <span class="keyword">if</span> (currentLinePointY &lt; radius) &#123;</span><br><span class="line">            backCircleY = radius - sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (backY &lt; backCircleY) &#123;</span><br><span class="line">                backY = backCircleY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentLinePointY &gt; radius) &#123;</span><br><span class="line">            backCircleY = radius + sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (backY &gt; backCircleY) &#123;</span><br><span class="line">                backY = backCircleY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fabs(<span class="number">0</span> - x) &lt; <span class="number">0.001</span>) &#123;</span><br><span class="line">            backStartPoint = <span class="built_in">CGPointMake</span>(x + offset, backY + offset);</span><br><span class="line">            <span class="built_in">CGPathMoveToPoint</span>(backPath, <span class="literal">NULL</span>, backStartPoint.x, backStartPoint.y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        backEndPoint = <span class="built_in">CGPointMake</span>(x + offset, backY + offset);</span><br><span class="line">        <span class="built_in">CGPathAddLineToPoint</span>(backPath, <span class="literal">nil</span>, backEndPoint.x, backEndPoint.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> centerPoint = <span class="built_in">CGPointMake</span>(fullRect.size.width / <span class="number">2</span>, fullRect.size.height / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制前浪圆弧</span></span><br><span class="line">    <span class="built_in">CGFloat</span> frontStart = [<span class="keyword">self</span> calculateRotateDegree:centerPoint point:frontStartPoint];</span><br><span class="line">    <span class="built_in">CGFloat</span> frontEnd = [<span class="keyword">self</span> calculateRotateDegree:centerPoint point:frontEndPoint];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPathAddArc</span>(frontPath, <span class="literal">nil</span>, centerPoint.x, centerPoint.y, waveRect.size.width / <span class="number">2</span>, frontEnd, frontStart, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(context, frontPath);</span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">    <span class="comment">//推入</span></span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathStroke);</span><br><span class="line">    <span class="built_in">CGPathRelease</span>(frontPath);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制后浪圆弧</span></span><br><span class="line">    <span class="built_in">CGFloat</span> backStart = [<span class="keyword">self</span> calculateRotateDegree:centerPoint point:backStartPoint];</span><br><span class="line">    <span class="built_in">CGFloat</span> backEnd = [<span class="keyword">self</span> calculateRotateDegree:centerPoint point:backEndPoint];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPathAddArc</span>(backPath, <span class="literal">nil</span>, centerPoint.x, centerPoint.y, waveRect.size.width / <span class="number">2</span>, backEnd, backStart, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [_backWaterColor <span class="built_in">CGColor</span>]);</span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(context, backPath);</span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(context);</span><br><span class="line">    <span class="comment">//推入</span></span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathStroke);</span><br><span class="line">    <span class="built_in">CGPathRelease</span>(backPath);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码较长，可能也比较难以理解。下面我将会对上述代码简单解读一下，已前浪为例（前浪和后浪的实现方式基本一样，只是两个浪正余弦函数不一样而已）。两个浪都是由一条曲线和和一个圆弧构成的封闭区间，曲线的x区间为<code>[0, waveRect.size.width]</code>，y值坐标为<code>frontY = a * sin( x / 180 * M_PI + 4 * b / M_PI ) * amplitude + currentLinePointY;</code>(currentLinePointY为偏移量)，通过for循环自增x，计算出y的位置来不断<code>CGPathAddLineToPoint</code>绘制出一条曲线，这就构成了波浪的曲线。然后我们需要根据波浪曲线的起始点和结束点以及圆心点(fullRect.size.width / 2, fullRect.size.height / 2)，来绘制一段封闭的圆弧。<br>这里就需要用到<code>CGPathAddArc</code>方法；<code>CGPathAddArc</code>方法和<code>CGContextAddArc</code>类似。需要先计算出点波浪的起始点和结束点分别与圆心之间的夹角。知道两点计算夹角的方式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  根据圆心点和圆上一个点计算角度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param centerPoint 圆心点</span></span><br><span class="line"><span class="comment"> *  @param point       圆上的一个点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 角度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)calculateRotateDegree:(<span class="built_in">CGPoint</span>)centerPoint point:(<span class="built_in">CGPoint</span>)point &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> rotateDegree = asin(fabs(point.y - centerPoint.y) / (sqrt(pow(point.x - centerPoint.x, <span class="number">2</span>) + pow(point.y - centerPoint.y, <span class="number">2</span>))));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果point纵坐标大于原点centerPoint纵坐标(在第一和第二象限)</span></span><br><span class="line">    <span class="keyword">if</span> (point.y &gt; centerPoint.y) &#123;</span><br><span class="line">        <span class="comment">//第一象限</span></span><br><span class="line">        <span class="keyword">if</span> (point.x &gt;= centerPoint.x) &#123;</span><br><span class="line">            rotateDegree = rotateDegree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二象限</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rotateDegree = M_PI - rotateDegree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">//第三和第四象限</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (point.x &lt;= centerPoint.x) <span class="comment">//第三象限，不做任何处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            rotateDegree = M_PI + rotateDegree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//第四象限</span></span><br><span class="line">        &#123;</span><br><span class="line">            rotateDegree = <span class="number">2</span> * M_PI - rotateDegree;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateDegree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="波浪绘制的相关判断"><a href="#波浪绘制的相关判断" class="headerlink" title="波浪绘制的相关判断"></a>波浪绘制的相关判断</h4><p>由于曲线x区间是<code>[0, waveRect.size.width]</code>，y值是根据公式<code>frontY = a * sin( x / 180 * M_PI + 4 * b / M_PI ) * amplitude + currentLinePointY;</code>计算出来的，但是最终构成的波浪是一个球形的，所以对于计算出来的y值坐标，我们需要判断它是否在圆上，如果不在圆上，我们应该将它移到圆上。</p>
<p>判断分为两种情况：</p>
<h5 id="currentLinePointY-lt-fullRect-size-height-2"><a href="#currentLinePointY-lt-fullRect-size-height-2" class="headerlink" title="currentLinePointY&lt;fullRect.size.height / 2"></a>currentLinePointY&lt;fullRect.size.height / 2</h5><p>当currentLinePointY&lt;fullRect.size.height / 2时，已知点的坐标x，根据公式<code>y1 = a * sin( x / 180 * M_PI + 4 * b / M_PI ) * amplitude + currentLinePointY;</code>算出来的点位置为(x, y1)，而在圆上点坐标为x的点的位置在(x,y2)，如果y1&lt;y2 则最终应该放到波浪上的点为 <code>(x,y2)</code>。</p>
<img src="/posts/720308c7cbe4e8d5/905614-6d980e01c0a78df8.png" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-6d980e01c0a78df8.png) -->

<h5 id="currentLinePointY-gt-fullRect-size-height-2"><a href="#currentLinePointY-gt-fullRect-size-height-2" class="headerlink" title="currentLinePointY&gt;fullRect.size.height / 2"></a>currentLinePointY&gt;fullRect.size.height / 2</h5><p>同理当currentLinePointY&gt;fullRect.size.height / 2时，已知点的坐标x，根据公式<code>y1 = a * sin( x / 180 * M_PI + 4 * b / M_PI ) * amplitude + currentLinePointY;</code>算出来的点位置为(x, y1)，而在圆上点坐标为x的点的位置在(x,y2)，如果y1&gt;y2 则最终应该放到波浪上的点为 <code>(x,y2)</code>。</p>
<img src="/posts/720308c7cbe4e8d5/905614-11de31e505d895a1.png" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-11de31e505d895a1.png) -->

<p>其中判断的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frontY = a * sin( x / <span class="number">180</span> * M_PI + <span class="number">4</span> * b / M_PI ) * amplitude + currentLinePointY;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">CGFloat</span> frontCircleY = frontY;</span><br><span class="line"><span class="keyword">if</span> (currentLinePointY &lt; radius) &#123;</span><br><span class="line">    frontCircleY = radius - sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (frontY &lt; frontCircleY) &#123;</span><br><span class="line">        frontY = frontCircleY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentLinePointY &gt; radius) &#123;</span><br><span class="line">    frontCircleY = radius + sqrt(pow(radius, <span class="number">2</span>) - pow((radius - x), <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (frontY &gt; frontCircleY) &#123;</span><br><span class="line">        frontY = frontCircleY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中当<code>currentLinePointY &lt; radius </code>时，<code>y2=radius - sqrt(pow(radius, 2) - pow((radius - x), 2))</code>;<br>当<code>currentLinePointY &gt; radius</code>时，<code>y2=radius + sqrt(pow(radius, 2) - pow((radius - x), 2))</code>；</p>
<p>这样就构成了一个如下的效果：</p>
<img src="/posts/720308c7cbe4e8d5/905614-cb9896a7ba570a22.png" class="">
<!-- ![](http://upload-images.jianshu.io/upload_images/905614-cb9896a7ba570a22.png) -->

<p>然后通过Timer不断的改变<code>a</code>、<code>b</code>的值就得到了我想要的动画效果。</p>
<p>Github地址：<a target="_blank" rel="noopener" href="https://github.com/Jvaeyhcd/HcdProcessView">https://github.com/Jvaeyhcd/HcdProcessView</a></p>

    </div>
  </article>

  <ul class="post-pager">
    
    <li class="previous">
      <a href="/posts/f705d18d988770f0.html">← Previous Post</a>
    </li>
    
    
    <li class="next">
      <a href="/posts/dffc5afb10488f2f.html">Next Post →</a>
    </li>
    
  </ul>

  <div class="box-section shadow box-comment">
    <!-- 
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'jvaeyhcd';
    
    var disqus_url = 'https://jvaeyhcd.github.io/posts/720308c7cbe4e8d5.html';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//jvaeyhcd.disqus.com/count.js" async></script>


 -->
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container"></div>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '29d526fe1e0f29d6b28c',
        clientSecret: '1e5c674f3cbce0ba7d19045138d69ef800d5bd21',
        id: window.location.pathname,
        repo: 'jvaeyhcd.github.io',
        owner: 'Jvaeyhcd',
        admin: 'Jvaeyhcd'
    })
    gitalk.render('gitalk-container')
</script>
  </div>
</div>
      </div>
    </div>
  </div>
  <div class="layout-footer">
    <div id="bottom-outer" class="container">
  <div id="bottom-inner">
    <span>
    &copy; 2016-2022 Jvaeyhcd using
    <a style="color:#007fff;" target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>.
    </span>
    
      <div class="busuanzi-box">
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv" style='display:none'>
                本站访客数<span id="busuanzi_value_site_uv"></span>人
        </span>
      </div>
    
    <a class="footer-icon" target="_blank" rel="noopener" href="https://github.com/Jvaeyhcd"><i class="fab fa-github"></i></a>
  </div>
</div>
<link href="https://unpkg.com/ionicons@4.5.10-0/dist/css/ionicons.min.css" rel="stylesheet">
<button id="totop" class="back-top">
  <i class="icon ion-md-arrow-dropup"></i>
</button>

<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="/js/back-top.js"></script>

  </div>
</div>



  <!-- scripts list from theme config.yml -->
  
    <script src="/js/dexo.js"></script>
  
    <script src="/js/helper.js"></script>
  


</body>
</html>
